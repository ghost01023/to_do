
--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\BubbleMenu.tsx ---
import { BubbleMenuPlugin, BubbleMenuPluginProps } from '@tiptap/extension-bubble-menu'
import React, { useEffect, useState } from 'react'

import { useCurrentEditor } from './Context.js'

type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;

export type BubbleMenuProps = Omit<Optional<BubbleMenuPluginProps, 'pluginKey'>, 'element' | 'editor'> & {
  editor: BubbleMenuPluginProps['editor'] | null;
  className?: string;
  children: React.ReactNode;
  updateDelay?: number;
};

export const BubbleMenu = (props: BubbleMenuProps) => {
  const [element, setElement] = useState<HTMLDivElement | null>(null)
  const { editor: currentEditor } = useCurrentEditor()

  useEffect(() => {
    if (!element) {
      return
    }

    if (props.editor?.isDestroyed || currentEditor?.isDestroyed) {
      return
    }

    const {
      pluginKey = 'bubbleMenu', editor, tippyOptions = {}, updateDelay, shouldShow = null,
    } = props

    const menuEditor = editor || currentEditor

    if (!menuEditor) {
      console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.')
      return
    }

    const plugin = BubbleMenuPlugin({
      updateDelay,
      editor: menuEditor,
      element,
      pluginKey,
      shouldShow,
      tippyOptions,
    })

    menuEditor.registerPlugin(plugin)
    return () => { menuEditor.unregisterPlugin(pluginKey) }
  }, [props.editor, currentEditor, element])

  return (
    <div ref={setElement} className={props.className} style={{ visibility: 'hidden' }}>
      {props.children}
    </div>
  )
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\Context.tsx ---
import { Editor } from '@tiptap/core'
import React, {
  createContext, HTMLAttributes, ReactNode, useContext,
} from 'react'

import { EditorContent } from './EditorContent.js'
import { useEditor, UseEditorOptions } from './useEditor.js'

export type EditorContextValue = {
  editor: Editor | null;
}

export const EditorContext = createContext<EditorContextValue>({
  editor: null,
})

export const EditorConsumer = EditorContext.Consumer

/**
 * A hook to get the current editor instance.
 */
export const useCurrentEditor = () => useContext(EditorContext)

export type EditorProviderProps = {
  children?: ReactNode;
  slotBefore?: ReactNode;
  slotAfter?: ReactNode;
  editorContainerProps?: HTMLAttributes<HTMLDivElement>;
} & UseEditorOptions

/**
 * This is the provider component for the editor.
 * It allows the editor to be accessible across the entire component tree
 * with `useCurrentEditor`.
 */
export function EditorProvider({
  children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions
}: EditorProviderProps) {
  const editor = useEditor(editorOptions)

  if (!editor) {
    return null
  }

  return (
    <EditorContext.Provider value={{ editor }}>
      {slotBefore}
      <EditorConsumer>
        {({ editor: currentEditor }) => (
          <EditorContent editor={currentEditor} {...editorContainerProps} />
        )}
      </EditorConsumer>
      {children}
      {slotAfter}
    </EditorContext.Provider>
  )
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\EditorContent.tsx ---
import { Editor } from '@tiptap/core'
import React, {
  ForwardedRef, forwardRef, HTMLProps, LegacyRef, MutableRefObject,
} from 'react'
import ReactDOM from 'react-dom'
import { useSyncExternalStore } from 'use-sync-external-store/shim'

import { ContentComponent, EditorWithContentComponent } from './Editor.js'
import { ReactRenderer } from './ReactRenderer.js'

const mergeRefs = <T extends HTMLDivElement>(
  ...refs: Array<MutableRefObject<T> | LegacyRef<T> | undefined>
) => {
  return (node: T) => {
    refs.forEach(ref => {
      if (typeof ref === 'function') {
        ref(node)
      } else if (ref) {
        (ref as MutableRefObject<T | null>).current = node
      }
    })
  }
}

/**
 * This component renders all of the editor's node views.
 */
const Portals: React.FC<{ contentComponent: ContentComponent }> = ({
  contentComponent,
}) => {
  // For performance reasons, we render the node view portals on state changes only
  const renderers = useSyncExternalStore(
    contentComponent.subscribe,
    contentComponent.getSnapshot,
    contentComponent.getServerSnapshot,
  )

  // This allows us to directly render the portals without any additional wrapper
  return (
    <>
      {Object.values(renderers)}
    </>
  )
}

export interface EditorContentProps extends HTMLProps<HTMLDivElement> {
  editor: Editor | null;
  innerRef?: ForwardedRef<HTMLDivElement | null>;
}

function getInstance(): ContentComponent {
  const subscribers = new Set<() => void>()
  let renderers: Record<string, React.ReactPortal> = {}

  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback: () => void) {
      subscribers.add(callback)
      return () => {
        subscribers.delete(callback)
      }
    },
    getSnapshot() {
      return renderers
    },
    getServerSnapshot() {
      return renderers
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id: string, renderer: ReactRenderer) {
      renderers = {
        ...renderers,
        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id),
      }

      subscribers.forEach(subscriber => subscriber())
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id: string) {
      const nextRenderers = { ...renderers }

      delete nextRenderers[id]
      renderers = nextRenderers
      subscribers.forEach(subscriber => subscriber())
    },
  }
}

export class PureEditorContent extends React.Component<
  EditorContentProps,
  { hasContentComponentInitialized: boolean }
> {
  editorContentRef: React.RefObject<any>

  initialized: boolean

  unsubscribeToContentComponent?: () => void

  constructor(props: EditorContentProps) {
    super(props)
    this.editorContentRef = React.createRef()
    this.initialized = false

    this.state = {
      hasContentComponentInitialized: Boolean((props.editor as EditorWithContentComponent | null)?.contentComponent),
    }
  }

  componentDidMount() {
    this.init()
  }

  componentDidUpdate() {
    this.init()
  }

  init() {
    const editor = this.props.editor as EditorWithContentComponent | null

    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return
      }

      const element = this.editorContentRef.current

      element.append(...editor.options.element.childNodes)

      editor.setOptions({
        element,
      })

      editor.contentComponent = getInstance()

      // Has the content component been initialized?
      if (!this.state.hasContentComponentInitialized) {
        // Subscribe to the content component
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState(prevState => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true,
              }
            }
            return prevState
          })

          // Unsubscribe to previous content component
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent()
          }
        })
      }

      editor.createNodeViews()

      this.initialized = true
    }
  }

  componentWillUnmount() {
    const editor = this.props.editor as EditorWithContentComponent | null

    if (!editor) {
      return
    }

    this.initialized = false

    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {},
      })
    }

    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent()
    }

    editor.contentComponent = null

    if (!editor.options.element.firstChild) {
      return
    }

    const newElement = document.createElement('div')

    newElement.append(...editor.options.element.childNodes)

    editor.setOptions({
      element: newElement,
    })
  }

  render() {
    const { editor, innerRef, ...rest } = this.props

    return (
      <>
        <div ref={mergeRefs(innerRef, this.editorContentRef)} {...rest} />
        {/* @ts-ignore */}
        {editor?.contentComponent && <Portals contentComponent={editor.contentComponent} />}
      </>
    )
  }
}

// EditorContent should be re-created whenever the Editor instance changes
const EditorContentWithKey = forwardRef<HTMLDivElement, EditorContentProps>(
  (props: Omit<EditorContentProps, 'innerRef'>, ref) => {
    const key = React.useMemo(() => {
      return Math.floor(Math.random() * 0xffffffff).toString()
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [props.editor])

    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement
    return React.createElement(PureEditorContent, {
      key,
      innerRef: ref,
      ...props,
    })
  },
)

export const EditorContent = React.memo(EditorContentWithKey)


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\FloatingMenu.tsx ---
import { FloatingMenuPlugin, FloatingMenuPluginProps } from '@tiptap/extension-floating-menu'
import React, {
  useEffect, useState,
} from 'react'

import { useCurrentEditor } from './Context.js'

type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>

export type FloatingMenuProps = Omit<Optional<FloatingMenuPluginProps, 'pluginKey'>, 'element' | 'editor'> & {
  editor: FloatingMenuPluginProps['editor'] | null;
  className?: string,
  children: React.ReactNode
}

export const FloatingMenu = (props: FloatingMenuProps) => {
  const [element, setElement] = useState<HTMLDivElement | null>(null)
  const { editor: currentEditor } = useCurrentEditor()

  useEffect(() => {
    if (!element) {
      return
    }

    if (props.editor?.isDestroyed || currentEditor?.isDestroyed) {
      return
    }

    const {
      pluginKey = 'floatingMenu',
      editor,
      tippyOptions = {},
      shouldShow = null,
    } = props

    const menuEditor = editor || currentEditor

    if (!menuEditor) {
      console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.')
      return
    }

    const plugin = FloatingMenuPlugin({
      pluginKey,
      editor: menuEditor,
      element,
      tippyOptions,
      shouldShow,
    })

    menuEditor.registerPlugin(plugin)
    return () => { menuEditor.unregisterPlugin(pluginKey) }
  }, [
    props.editor,
    currentEditor,
    element,
  ])

  return (
    <div ref={setElement} className={props.className} style={{ visibility: 'hidden' }}>
      {props.children}
    </div>
  )
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\NodeViewContent.tsx ---
import React from 'react'

import { useReactNodeView } from './useReactNodeView.js'

export interface NodeViewContentProps {
  [key: string]: any,
  as?: React.ElementType,
}

export const NodeViewContent: React.FC<NodeViewContentProps> = props => {
  const Tag = props.as || 'div'
  const { nodeViewContentRef } = useReactNodeView()

  return (
    // @ts-ignore
    <Tag
      {...props}
      ref={nodeViewContentRef}
      data-node-view-content=""
      style={{
        whiteSpace: 'pre-wrap',
        ...props.style,
      }}
    />
  )
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\NodeViewWrapper.tsx ---
import React from 'react'

import { useReactNodeView } from './useReactNodeView.js'

export interface NodeViewWrapperProps {
  [key: string]: any,
  as?: React.ElementType,
}

export const NodeViewWrapper: React.FC<NodeViewWrapperProps> = React.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView()
  const Tag = props.as || 'div'

  return (
    // @ts-ignore
    <Tag
      {...props}
      ref={ref}
      data-node-view-wrapper=""
      onDragStart={onDragStart}
      style={{
        whiteSpace: 'normal',
        ...props.style,
      }}
    />
  )
})


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\ReactNodeViewRenderer.tsx ---
import {
  DecorationWithType,
  Editor,
  getRenderedAttributes,
  NodeView,
  NodeViewProps,
  NodeViewRenderer,
  NodeViewRendererOptions,
} from '@tiptap/core'
import { Node, Node as ProseMirrorNode } from '@tiptap/pm/model'
import { Decoration, DecorationSource, NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'
import React, { ComponentType } from 'react'

import { EditorWithContentComponent } from './Editor.js'
import { ReactRenderer } from './ReactRenderer.js'
import { ReactNodeViewContext, ReactNodeViewContextProps } from './useReactNodeView.js'

export interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {
  /**
   * This function is called when the node view is updated.
   * It allows you to compare the old node with the new node and decide if the component should update.
   */
  update:
    | ((props: {
        oldNode: ProseMirrorNode;
        oldDecorations: readonly Decoration[];
        oldInnerDecorations: DecorationSource;
        newNode: ProseMirrorNode;
        newDecorations: readonly Decoration[];
        innerDecorations: DecorationSource;
        updateProps: () => void;
      }) => boolean)
    | null;
  /**
   * The tag name of the element wrapping the React component.
   */
  as?: string;
  /**
   * The class name of the element wrapping the React component.
   */
  className?: string;
  /**
   * Attributes that should be applied to the element wrapping the React component.
   * If this is a function, it will be called each time the node view is updated.
   * If this is an object, it will be applied once when the node view is mounted.
   */
  attrs?:
    | Record<string, string>
    | ((props: {
        node: ProseMirrorNode;
        HTMLAttributes: Record<string, any>;
      }) => Record<string, string>);
}

export class ReactNodeView<
  Component extends ComponentType<NodeViewProps> = ComponentType<NodeViewProps>,
  NodeEditor extends Editor = Editor,
  Options extends ReactNodeViewRendererOptions = ReactNodeViewRendererOptions,
> extends NodeView<Component, NodeEditor, Options> {
  /**
   * The renderer instance.
   */
  renderer!: ReactRenderer<unknown, NodeViewProps>

  /**
   * The element that holds the rich-text content of the node.
   */
  contentDOMElement!: HTMLElement | null

  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations as DecorationWithType[],
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: false,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode(),
    } satisfies NodeViewProps

    if (!(this.component as any).displayName) {
      const capitalizeFirstChar = (string: string): string => {
        return string.charAt(0).toUpperCase() + string.substring(1)
      }

      this.component.displayName = capitalizeFirstChar(this.extension.name)
    }

    const onDragStart = this.onDragStart.bind(this)
    const nodeViewContentRef: ReactNodeViewContextProps['nodeViewContentRef'] = element => {
      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {
        element.appendChild(this.contentDOMElement)
      }
    }
    const context = { onDragStart, nodeViewContentRef }
    const Component = this.component
    // For performance reasons, we memoize the provider component
    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render
    const ReactNodeViewProvider: React.FunctionComponent<NodeViewProps> = React.memo(
      componentProps => {
        return (
          <ReactNodeViewContext.Provider value={context}>
            {React.createElement(Component, componentProps)}
          </ReactNodeViewContext.Provider>
        )
      },
    )

    ReactNodeViewProvider.displayName = 'ReactNodeView'

    if (this.node.isLeaf) {
      this.contentDOMElement = null
    } else if (this.options.contentDOMElementTag) {
      this.contentDOMElement = document.createElement(this.options.contentDOMElementTag)
    } else {
      this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div')
    }

    if (this.contentDOMElement) {
      this.contentDOMElement.dataset.nodeViewContentReact = ''
      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari
      // With this fix it seems to work fine
      // See: https://github.com/ueberdosis/tiptap/issues/1197
      this.contentDOMElement.style.whiteSpace = 'inherit'
    }

    let as = this.node.isInline ? 'span' : 'div'

    if (this.options.as) {
      as = this.options.as
    }

    const { className = '' } = this.options

    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)

    this.renderer = new ReactRenderer(ReactNodeViewProvider, {
      editor: this.editor,
      props,
      as,
      className: `node-${this.node.type.name} ${className}`.trim(),
    })

    this.editor.on('selectionUpdate', this.handleSelectionUpdate)
    this.updateElementAttributes()
  }

  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (
      this.renderer.element.firstElementChild
      && !this.renderer.element.firstElementChild?.hasAttribute('data-node-view-wrapper')
    ) {
      throw Error('Please use the NodeViewWrapper component for your node view.')
    }

    return this.renderer.element as HTMLElement
  }

  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    if (this.node.isLeaf) {
      return null
    }

    return this.contentDOMElement
  }

  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from, to } = this.editor.state.selection
    const pos = this.getPos()

    if (typeof pos !== 'number') {
      return
    }

    if (from <= pos && to >= pos + this.node.nodeSize) {
      if (this.renderer.props.selected) {
        return
      }

      this.selectNode()
    } else {
      if (!this.renderer.props.selected) {
        return
      }

      this.deselectNode()
    }
  }

  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(
    node: Node,
    decorations: readonly Decoration[],
    innerDecorations: DecorationSource,
  ): boolean {
    const rerenderComponent = (props?: Record<string, any>) => {
      this.renderer.updateProps(props)
      if (typeof this.options.attrs === 'function') {
        this.updateElementAttributes()
      }
    }

    if (node.type !== this.node.type) {
      return false
    }

    if (typeof this.options.update === 'function') {
      const oldNode = this.node
      const oldDecorations = this.decorations
      const oldInnerDecorations = this.innerDecorations

      this.node = node
      this.decorations = decorations
      this.innerDecorations = innerDecorations

      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        oldInnerDecorations,
        innerDecorations,
        updateProps: () => rerenderComponent({ node, decorations, innerDecorations }),
      })
    }

    if (
      node === this.node
      && this.decorations === decorations
      && this.innerDecorations === innerDecorations
    ) {
      return true
    }

    this.node = node
    this.decorations = decorations
    this.innerDecorations = innerDecorations

    rerenderComponent({ node, decorations, innerDecorations })

    return true
  }

  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: true,
    })
    this.renderer.element.classList.add('ProseMirror-selectednode')
  }

  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: false,
    })
    this.renderer.element.classList.remove('ProseMirror-selectednode')
  }

  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy()
    this.editor.off('selectionUpdate', this.handleSelectionUpdate)
    this.contentDOMElement = null
  }

  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let attrsObj: Record<string, string> = {}

      if (typeof this.options.attrs === 'function') {
        const extensionAttributes = this.editor.extensionManager.attributes
        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes)

        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes })
      } else {
        attrsObj = this.options.attrs
      }

      this.renderer.updateAttributes(attrsObj)
    }
  }
}

/**
 * Create a React node view renderer.
 */
export function ReactNodeViewRenderer(
  component: ComponentType<NodeViewProps>,
  options?: Partial<ReactNodeViewRendererOptions>,
): NodeViewRenderer {
  return props => {
    // try to get the parent component
    // this is important for vue devtools to show the component hierarchy correctly
    // maybe it’s `undefined` because <editor-content> isn’t rendered yet
    if (!(props.editor as EditorWithContentComponent).contentComponent) {
      return {} as unknown as ProseMirrorNodeView
    }

    return new ReactNodeView(component, props, options)
  }
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\node_modules\@tiptap\react\src\ReactRenderer.tsx ---
import { Editor } from '@tiptap/core'
import React from 'react'
import { flushSync } from 'react-dom'

import { EditorWithContentComponent } from './Editor.js'

/**
 * Check if a component is a class component.
 * @param Component
 * @returns {boolean}
 */
function isClassComponent(Component: any) {
  return !!(
    typeof Component === 'function'
    && Component.prototype
    && Component.prototype.isReactComponent
  )
}

/**
 * Check if a component is a forward ref component.
 * @param Component
 * @returns {boolean}
 */
function isForwardRefComponent(Component: any) {
  return !!(
    typeof Component === 'object'
    && Component.$$typeof?.toString() === 'Symbol(react.forward_ref)'
  )
}

export interface ReactRendererOptions {
  /**
   * The editor instance.
   * @type {Editor}
   */
  editor: Editor,

  /**
   * The props for the component.
   * @type {Record<string, any>}
   * @default {}
   */
  props?: Record<string, any>,

  /**
   * The tag name of the element.
   * @type {string}
   * @default 'div'
   */
  as?: string,

  /**
   * The class name of the element.
   * @type {string}
   * @default ''
   * @example 'foo bar'
   */
  className?: string,
}

type ComponentType<R, P> =
  React.ComponentClass<P> |
  React.FunctionComponent<P> |
  React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<R>>;

/**
 * The ReactRenderer class. It's responsible for rendering React components inside the editor.
 * @example
 * new ReactRenderer(MyComponent, {
 *   editor,
 *   props: {
 *     foo: 'bar',
 *   },
 *   as: 'span',
 * })
*/
export class ReactRenderer<R = unknown, P extends Record<string, any> = object> {
  id: string

  editor: Editor

  component: any

  element: Element

  props: P

  reactElement: React.ReactNode

  ref: R | null = null

  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(component: ComponentType<R, P>, {
    editor,
    props = {},
    as = 'div',
    className = '',
  }: ReactRendererOptions) {
    this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString()
    this.component = component
    this.editor = editor as EditorWithContentComponent
    this.props = props as P
    this.element = document.createElement(as)
    this.element.classList.add('react-renderer')

    if (className) {
      this.element.classList.add(...className.split(' '))
    }

    if (this.editor.isInitialized) {
      // On first render, we need to flush the render synchronously
      // Renders afterwards can be async, but this fixes a cursor positioning issue
      flushSync(() => {
        this.render()
      })
    } else {
      this.render()
    }
  }

  /**
   * Render the React component.
   */
  render(): void {
    const Component = this.component
    const props = this.props
    const editor = this.editor as EditorWithContentComponent

    if (isClassComponent(Component) || isForwardRefComponent(Component)) {
      // @ts-ignore This is a hack to make the ref work
      props.ref = (ref: R) => {
        this.ref = ref
      }
    }

    this.reactElement = <Component {...props} />

    editor?.contentComponent?.setRenderer(this.id, this)
  }

  /**
   * Re-renders the React component with new props.
   */
  updateProps(props: Record<string, any> = {}): void {
    this.props = {
      ...this.props,
      ...props,
    }

    this.render()
  }

  /**
   * Destroy the React component.
   */
  destroy(): void {
    const editor = this.editor as EditorWithContentComponent

    editor?.contentComponent?.removeRenderer(this.id)
  }

  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(attributes: Record<string, string>): void {
    Object.keys(attributes).forEach(key => {
      this.element.setAttribute(key, attributes[key])
    })
  }
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import './tip-tap.css';

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\page.tsx ---
"use client";

// PREDEFINED
import React, { useState, useEffect } from "react";

// USER DEFINED
import { TipTapEditor } from "./components/tiptap/tip-tap";
import NoteContainer from "./note_container/note_container";
import NewNoteButton from "./components/new_note_button/new_note_button";
import FilterMenu from "./components/filter_menu/filter_menu";
import Header from "@/app/components/header/header";
import ExpandableNoteEditor from "@/app/components/expandable_note_editor/expand_editor";

let noteContent = "";

export interface Note {
  id: number;
  dateCreated: number;
  dateModified: number;
  content: string;
}

let count = 0;
const nd = [{"id":1730559100,"dateCreated":1730559100,"dateModified":1730559115,"content":"Content for note with dateCreated = 1730559100"},{"id":1730644610,"dateCreated":1730644610,"dateModified":1730644625,"content":"Content for note with dateCreated = 1730644610"},{"id":1731993480,"dateCreated":1731993480,"dateModified":1731993495,"content":"Content for note with dateCreated = 1731993480"},{"id":1732635246,"dateCreated":1732635246,"dateModified":1732635261,"content":"Content for note with dateCreated = 1732635246"},{"id":1732876255,"dateCreated":1732876255,"dateModified":1732876270,"content":"Content for note with dateCreated = 1732876255"},{"id":1734017721,"dateCreated":1734017721,"dateModified":1734017736,"content":"Content for note with dateCreated = 1734017721"},{"id":1734525159,"dateCreated":1734525159,"dateModified":1734525174,"content":"Content for note with dateCreated = 1734525159"},{"id":1734891617,"dateCreated":1734891617,"dateModified":1734891632,"content":"Content for note with dateCreated = 1734891617"},{"id":1735041689,"dateCreated":1735041689,"dateModified":1735041704,"content":"Content for note with dateCreated = 1735041689"},{"id":1735641839,"dateCreated":1735641839,"dateModified":1735641854,"content":"Content for note with dateCreated = 1735641839"}];
export default function Home() {
  const getNoteData = () => nd;
  
  const [noteData, setNoteData] = useState<Note[]>([]);
  const [sortedNoteData, setSortedNoteData] = useState<Note[]>([]);
  const [filteredNoteData, setFilteredNoteData] = useState<Note[]>([]);
  const [showEditor, setShowEditor] = useState(false);
  const [syncNoteDiv, setSyncNoteDiv] = useState<HTMLDivElement>();
  const [newNoteButton, setNewNoteButton] = useState(!showEditor);
  const [createNewNote, setCreateNewNote] = useState(false);

  // CLOSED WHEN A USER EITHER PRESSED [CLOSE] OR TYPES [CTRL+ALT+X] WHEN EDITOR IS OPEN
  const toggleEditor = (elem: React.MouseEvent<HTMLDivElement>) => {
    //if editor is already open, close it
    // also, extract heading, progress and textContent separately from target element
    noteContent = elem?.currentTarget?.querySelector(".note-content")?.innerHTML || "";
    setShowEditor(!showEditor);
  }

  // WHENEVER EDITOR IS SHOWS, NEW_NOTE_BUTTON IS HIDDEN AND THE OPPOSITE WHEN IT'S HIDDEN
  useEffect(() => {
  setNewNoteButton(!showEditor);
}, [showEditor]); // Runs whenever `alive` updates

  // RUN ONLY ONCE WHEN FETCHING DATA
  useEffect(() => {
    const fetchedData = getNoteData();
    setNoteData(prev => (JSON.stringify(prev) === JSON.stringify(fetchedData) ? prev : [...fetchedData]));
  }, []);

  // RUNS WHENEVER NOTE_DATA IS MODIFIED
  useEffect(() => {

    //SET SORT CONDITION HERE (data, percentage etc.)
    console.warn("noteData was set and am now sorting...");
    if(count++ === 10) {
      return;
    }
    setSortedNoteData([...noteData].sort((a, b) => b.dateCreated - a.dateCreated));
  }, [noteData]);

  // RUNS WHENEVER SORTED_NOTE_DATA IS RE-SORTED VIA DIFFERENT PARAMETERS
  useEffect(() => {
    //SET FILTRATION PARAMETER(s) HERE
    console.warn("sortedNoteData was set and am now filtering...");
    setFilteredNoteData(sortedNoteData.filter((note) => note.dateCreated % 1 === 0));
  }, [sortedNoteData]);

  // IMPLEMENT AUTH-0 LOGIN, SIGNUP HERE
  const authenticated = true;
  if (!authenticated) {
    return (
      <div>
        <h1>Login/Signup Page</h1>
      </div>
    )
  }
  return (
    <div className="grid gap-4 grid-cols-[1fr_5fr_2.5fr] grid-rows-[1fr_5fr_1fr]">
      <FilterMenu></FilterMenu>
      <Header></Header>
      {/* below div keeps empty space for the filter menu  */}
      <div className="col-span-1"></div> 
    <section className="col-span-2">
      {
      (showEditor && !createNewNote) ? (
          <TipTapEditor
              syncNoteDiv={syncNoteDiv} // FOR WHEN SYNCING||CLOSING
              noteContent={noteContent} // FOR LOADING
              noteData={noteData}
              setNoteData={setNoteData}
              setShowEditor={setShowEditor} // FOR CLOSING
          ></TipTapEditor>) : ""
      }
      {
        (showEditor && createNewNote) ?
            <TipTapEditor
              syncNoteDiv={undefined}
              noteData={noteData}
              setNoteData={setNoteData}
              noteContent={""}
              setShowEditor={setShowEditor}
            ></TipTapEditor> : ""
      }
      {
        // CLICKING ON NEW_NOTE_BUTTON WILL
        //1. OPEN EDITOR WITH EMPTY CONTENT
        //2. UPON CLOSURE OF EDITOR, THIS DATA WILL BE APPENDED INTO THE NOTE_DATA
        //3. NOTE_DATA LATEST NOTE WILL BE SYNCED
        newNoteButton ? (
            <NewNoteButton
                setCreateNewNote={setCreateNewNote}
                setShowEditor={setShowEditor}
            ></NewNoteButton>) : ""
      }
      <NoteContainer
          noteData={filteredNoteData}
          setSyncNoteDiv={setSyncNoteDiv}
          setShowEditor={toggleEditor}
      ></NoteContainer>
    </section>
    </div>
  );
}


--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\buttons\bold.svg ---
const BoldIcon = () => {
    return(
        <svg fill="#000000" version="1.1" id="Capa_1"
	 width="15px" height="15px" viewBox="0 0 25.072 25.072"
	 xmlSpace="preserve">
<g>
	<path d="M22.028,13.794c-0.962-0.79-2.632-1.461-5.011-2.016c2.207-0.555,3.746-1.305,4.623-2.246
		c0.875-0.943,1.312-2.02,1.312-3.227c0-1.146-0.346-2.229-1.035-3.244c-0.69-1.018-1.633-1.781-2.827-2.293
		C17.893,0.256,15.86,0,12.988,0H0.972v0.684c1.146,0,1.928,0.104,2.348,0.314C3.739,1.207,4.032,1.487,4.198,1.84
		c0.167,0.352,0.25,1.205,0.25,2.561v16.27c0,1.355-0.083,2.207-0.25,2.552c-0.166,0.346-0.456,0.627-0.868,0.842
		c-0.414,0.215-1.199,0.324-2.357,0.324v0.684H13.71c3.549,0,6.256-0.746,8.117-2.236c1.517-1.232,2.273-2.791,2.273-4.68
		C24.1,16.37,23.409,14.915,22.028,13.794z M10.29,1.405c1.799-0.012,3.105,0.168,3.92,0.537c0.812,0.369,1.438,0.908,1.875,1.617
		s0.656,1.617,0.656,2.727s-0.222,2.021-0.666,2.736c-0.443,0.715-1.08,1.27-1.912,1.664c-0.833,0.394-2.124,0.592-3.874,0.592
		V1.405L10.29,1.405z M16.927,21.141c-0.441,0.832-1.082,1.468-1.914,1.904c-0.832,0.436-1.739,0.654-2.727,0.654
		c-0.666,0-1.168-0.168-1.507-0.508c-0.339-0.34-0.509-0.842-0.509-1.508l0.02-0.924v-8.043c1.885-0.013,3.303,0.168,4.252,0.537
		s1.693,1.02,2.236,1.951c0.543,0.93,0.813,1.98,0.813,3.152C17.593,19.383,17.37,20.309,16.927,21.141z"/>
</g>
</svg>
    )
}

export default BoldIcon;

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\expandable_note_editor\expand_editor.tsx ---
import React, { useState } from 'react';
import { EditorContent, useEditor } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import { Minimize2, Maximize2 } from 'lucide-react';

const ExpandableNoteEditor = () => {
    const [isExpanded, setIsExpanded] = useState(false);
    const [content, setContent] = useState('Click to edit this note...');

    const editor = useEditor({
        extensions: [StarterKit],
        content: content,
        onUpdate: ({ editor }) => {
            setContent(editor.getHTML());
        },
    });

    return (
        <div className={`
      fixed 
      transition-all 
      duration-300 
      ease-in-out 
      bg-white 
      rounded-lg 
      shadow-lg 
      ${isExpanded ?
            'top-0 left-0 right-0 bottom-0 m-4 p-6 z-50' :
            'w-64 h-40 m-4 p-4 cursor-pointer hover:shadow-xl'
        }
    `}>
            {/* Header */}
            <div className="flex justify-between items-center mb-4">
                <h3 className="font-semibold text-gray-800">Quick Note</h3>
                <button
                    onClick={() => setIsExpanded(!isExpanded)}
                    className="p-1 hover:bg-gray-100 rounded-full transition-colors"
                >
                    {isExpanded ?
                        <Minimize2 className="w-5 h-5 text-gray-600" /> :
                        <Maximize2 className="w-5 h-5 text-gray-600" />
                    }
                </button>
            </div>

            {/* Content */}
            <div className={`
        overflow-auto
        ${isExpanded ? 'h-[calc(100%-4rem)]' : 'h-[calc(100%-2.5rem)]'}
      `}>
                {isExpanded ? (
                    <EditorContent
                        editor={editor}
                        className="prose max-w-none focus:outline-none"
                    />
                ) : (
                    <div
                        className="text-gray-600 text-sm line-clamp-3"
                        dangerouslySetInnerHTML={{ __html: content }}
                    />
                )}
            </div>

            {/* Optional status bar */}
            <div className="absolute bottom-2 right-4 text-xs text-gray-400">
                {isExpanded ? 'Editor mode' : 'Preview mode'}
            </div>
        </div>
    );
};

export default ExpandableNoteEditor;

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\filter_menu\filter_menu.tsx ---
const FilterMenu = () => {
    return(
    <div className="filter sort flex flex-nowrap flex-col flex-initial fixed bottom-6 left-2">
        <input type="text" className="flex-none" placeholder="/Type to filter..."></input>
        <select className="flex-none" >
          <option>tags</option>
          <option>content</option>
          <option>title</option>
        </select>
        <select className="flex-none" >
          <option>date created (latest)</option>
          <option>date modified (latest)</option>
          <option>completed (most)</option>
        </select>
        <select className="flex-none" >
          <option>high to low</option>
          <option>low to high</option>
        </select>
      </div>
    )
}

export default FilterMenu;

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\header\header.tsx ---
const Header = () => {
  return (
    <div className="bg-gray-800 text-white p-4 flex col-span-3 row-span-3">
      Temporary Header
    </div>
  );
};

export default Header;

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\new_note_button\new_note_button.tsx ---
import React from "react";

interface NewNoteButtonProps {
    setCreateNewNote: React.Dispatch<React.SetStateAction<boolean>>;
    setShowEditor: React.Dispatch<React.SetStateAction<boolean>>;
}


const NewNoteButton = ({setCreateNewNote, setShowEditor}: NewNoteButtonProps) => {
    return (
        <button
            onClick={() => {
            setCreateNewNote(true);
            setShowEditor(true);
        }}
            className="fixed right-5 bottom-4 text-2xl px-5 py-2.5 text-center inline-flex border-2 border-solid border-red-400 bg-red-400 rounded-md items-center focus:outline-none active:bg-red-400 transition duration-150 ease-in-out hover:bg-red-200">
            <svg
                className="w-4 h-4 me-2"
                fill="#000000"
                height="65px"
                width="65px"
                version="1.1"
                id="Layer_1"
                viewBox="0 0 512 512"
                xmlSpace="preserve">
                    <g>
                        <g>
                            <path d="M303.02,208.98V0H208.98v208.98H0v94.041h208.98V512h94.041V303.02H512V208.98H303.02z M480.653,271.673h-208.98v208.98
                                h-31.347v-208.98H31.347v-31.347h208.98V31.347h31.347v208.98h208.98V271.673z"/>
                        </g>
                    </g>
            </svg>
            New Note</button>
    )
}

export default NewNoteButton;

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\components\tiptap\tip-tap.tsx ---
// FEATURES OF THE NOTE-EDITOR
import Paragraph from '@tiptap/extension-paragraph'
import Text from '@tiptap/extension-text'
import Document from '@tiptap/extension-document'
import Italic from '@tiptap/extension-italic'
import Bold from '@tiptap/extension-bold'
import Strike from '@tiptap/extension-strike'
import BulletList from '@tiptap/extension-bullet-list'
import ListItem from '@tiptap/extension-list-item'
import TaskList from "@tiptap/extension-task-list";
import TaskItem from "@tiptap/extension-task-item";
import PlaceHolder from '@tiptap/extension-placeholder';
import TextStyle from '@tiptap/extension-text-style'
import { Color } from '@tiptap/extension-color';
import StarterKit from "@tiptap/starter-kit";
import { FloatingMenu, EditorContent, EditorProvider, useCurrentEditor } from '@tiptap/react'
import React, {useEffect, useState} from 'react'
// import { Dispatch } from 'react'

// BUTTON ASSETS FOR THE NOTE-EDITOR
import BoldIcon from "../buttons/bold";
import {Note} from "../../page";

interface MenuBarProps {
  syncNoteDiv?: HTMLDivElement | undefined;
  noteContent: string;
  setShowEditor: React.Dispatch<React.SetStateAction<boolean>>;
}

const MenuBar = ({syncNoteDiv, setShowEditor, noteContent}: MenuBarProps) => {
  const {editor} = useCurrentEditor();

const undo = () => {
    editor?.chain().focus().undo().run();
};


const redo = () => {
      editor?.chain().focus().redo().run();
};


const extractContent = () => {
  const content = editor?.getJSON();
  console.log(content);
}

const extractHTMLContent = () => {
  const content = editor?.getHTML();
  console.log(content);
  return content;
}

const syncCurrentNote = ({syncNoteDiv}: MenuBarProps) => {
  console.log("syncNote is currently");

  console.log(syncNoteDiv?.innerHTML);
  const content = extractHTMLContent();
  if (content && syncNoteDiv) {
  syncNoteDiv.innerHTML = content;
  } else if (content && !syncNoteDiv) {
    
  }
}


  if (!editor) {
    return (
    <div>
      <h1>Failed to load editor!</h1>
    </div>)
  }

  return (
    <div className={"tip-tap-container"}>
      {editor &&
          <FloatingMenu
          className="floating-menu"
          tippyOptions={{ duration: 100 }}
          editor={editor}>
        <button
          onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
          className={editor.isActive('heading', { level: 1 }) ? 'style-btn-active tip-tap-btn mr-2' : 'tip-tap-btn mr-2'}
        >
          H1
        </button>
        <button
          onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
          className={editor.isActive('heading', { level: 2 }) ? 'style-btn-active tip-tap-btn mr-2' : 'tip-tap-btn mr-2'}
        >
          H2
        </button>
        <button
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          className={editor.isActive('bulletList') ? 'style-btn-active tip-tap-btn mr-2' : 'tip-tap-btn mr-2'}
        >
          Bullet list
        </button>
      </FloatingMenu>}
      <div className="control-group">
        <div className="button-group flex flex-row gap-x-3 mb-3">
          <button
            onClick={() => editor.chain().focus().toggleItalic().run()}
            className={editor.isActive('italic') ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
          >
            Toggle italic
          </button>
          <button
          onClick={() => editor.chain().focus().toggleBold().run()}
          className={editor.isActive('bold') ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
          >
          
            <BoldIcon />
          </button>
          <button
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          className={editor.isActive('bulletList') ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
          >
            Toggle BulletList
          </button>
          <button
          onClick={undo}
          disabled={!editor?.can().undo()}
          className={editor?.can().undo() ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
          >
            Undo
          </button>
          <button
          onClick={() => editor.chain().focus().setColor('#958DF1').run()}
          className={editor.isActive('textStyle', { color: '#958DF1' }) ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
        >
          Purple
        </button>
          <button
          onClick={redo}
          disabled={!editor?.can().redo()}
          className={editor?.can().redo() ? 'style-btn-active tip-tap-btn' : 'tip-tap-btn'}
          >
            Redo
          </button>
          <br/>
          <button 
          onClick={() => editor.chain().focus().setHorizontalRule().run()}
          >
            Horizontal rule
          </button>
          <button
          onClick={extractContent}
          className="tip-tap-btn"
          >
            getJSON()
          </button>
          <button
          onClick={extractHTMLContent}
          className="tip-tap-btn"
          >
            getHTML()
          </button>
          <button
          onClick={() => syncCurrentNote({syncNoteDiv, setShowEditor, noteContent})}
          className="tip-tap-btn"
          >
            Sync
          </button>
          <button
          onClick={() => {
            if (syncNoteDiv) {
              syncCurrentNote({syncNoteDiv, setShowEditor, noteContent});
            }
            setShowEditor(false)
          }}
          >
            Close
          </button>
        </div>
      </div>
      <EditorContent editor={editor} />
    </div>
  )
}

const extensions = [
      Document, 
      Paragraph,
      Text, 
      Italic, 
      Bold, 
      Strike, 
      BulletList, 
      ListItem, 
      TaskList, 
      Color.configure({ types: [TextStyle.name, ListItem.name] }),
      TaskItem.configure({
        nested: true,
      }),
      PlaceHolder.configure({
        placeholder: `Write something new...`,
      }),
  StarterKit.configure({
    bulletList: {
      keepMarks: true,
      keepAttributes: false
    },
    orderedList: {
      keepMarks: true,
      keepAttributes: false
    },
  }),
    ];

interface EditorProps {
  noteContent: string,
  noteData: Note[],
  setNoteData: React.Dispatch<React.SetStateAction<Note[]>>,
  syncNoteDiv?: HTMLDivElement | undefined,
  setShowEditor: React.Dispatch<React.SetStateAction<boolean>>
}

interface SyncViaKeyPressProps {
  event: React.KeyboardEvent;
  syncNoteDiv?: HTMLDivElement;
}

const syncViaKeyPress = ({event}: SyncViaKeyPressProps) => {
  console.log(event);
  console.log(event.target);
  // if (event.ctrlKey && event.altKey && event.key=== "Enter") {
  //   syncNoteDiv(event.target)
  // }
}

export const TipTapEditor = ({noteContent, noteData, setNoteData, syncNoteDiv, setShowEditor}: EditorProps) => {
  // Handle new note creation
  const [hasAddedNote, setHasAddedNote] = useState(false);
  useEffect(() => {
    if (!syncNoteDiv && !hasAddedNote) {
      setNoteData((prevNoteData: Note[]) => [
        ...prevNoteData,
        {
          "id": Date.now(),
          "dateCreated": Date.now(),
          "dateModified": Date.now(),
          "content": "New note"
        }
      ]);
      setHasAddedNote(true);
    }
  }, [syncNoteDiv, hasAddedNote, setNoteData]);
  console.log("Tip tap editor is being rendered with the following text content:");
  if (!syncNoteDiv && !hasAddedNote) {
    return <div>Creating new note...</div>;
  }

  return (
      <div
          className={"tip-tap-editor-container fixed top-20 bg-red-200"}
          onKeyDown={(event) => syncViaKeyPress({event})}
      >
        <EditorProvider
            slotBefore={
              <MenuBar
                  syncNoteDiv={syncNoteDiv}
                  noteContent={noteContent}
                  setShowEditor={setShowEditor}
              />
            }
            extensions={extensions}
            content={noteContent}
        />
      </div>
  );
};

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\note_container\note_container.tsx ---
"use client";

import { NoteCard } from "./note_card/note_card"

import { Note } from "../page";

interface NoteContainerProps {
  noteData: Note[],
  setShowEditor: (elem: React.MouseEvent<HTMLDivElement>) => void,
  setSyncNoteDiv: (elem: HTMLDivElement) => void
}

export default function NoteContainer({noteData, setShowEditor, setSyncNoteDiv}:NoteContainerProps) {
  let frontRunnerMonth = 0;
  let frontRunnerYear = 0;
    return(
    <section className="note-container">
      {
        noteData.map((noteObject) => {
        const date = new Date(noteObject.dateCreated * 1000);
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        let newYear = false;
        let newMonth = false;

      if (year !== frontRunnerYear) {
        frontRunnerYear = year;
        newYear = true;
      }
      if (month !== frontRunnerMonth) {
        frontRunnerMonth = month;
        newMonth = true;
      }
        return (
          (newYear && newMonth) ?
              <div key={noteObject.id}>
              <p key={noteObject.id + "year"} className="text-red-400">New Year {frontRunnerYear}</p>
              <p key={noteObject.id + "month"} className="text-blue-600">New Month {frontRunnerMonth}</p>
              </div> :
              newYear ?
                  <p key={noteObject.id + "year"} className="text-red-400">New Year {frontRunnerYear}</p> :
                  newMonth ?
                      <p key={noteObject.id + "month"} className="text-blue-600">New Month {frontRunnerMonth}</p> :
              <NoteCard
                  key={noteObject.id}
                  setShowEditor={setShowEditor}
                  setSyncNoteDiv={setSyncNoteDiv}
                  htmlContent={noteObject.content}
              ></NoteCard>
        )})
      }
    </section>)
}

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\note_container\note_card\note_card.tsx ---
"use client";

import "./style.css"
import React from "react";

interface NoteCardTypes {
    htmlContent: string,
    setShowEditor: (elem: React.MouseEvent<HTMLDivElement>) => void,
    setSyncNoteDiv: (elem: HTMLDivElement) => void,
}

export const NoteCard = (
    {
        htmlContent,
        setShowEditor,
        setSyncNoteDiv
    }: NoteCardTypes) => {
  console.log(htmlContent);
    return(
    <div
        className={"note-card duration-300 ease-in-out hover:p-7 hover:m-3 bg-slate-700/75 rounded-md hover:bg-slate-700/65 hover:cursor-pointer p-5 text-white"}
        onClick={(elem) => {setShowEditor(elem); setSyncNoteDiv(elem.currentTarget)}}
    ><p
        className={"note-status"}
    ><span
        className="inline-flex items-baseline">
    </span>
        In Progress</p>
        <p
            className={"note-heading"}
        >Title of Note</p>
        <div className={"note-content max-h-60"}>
        {htmlContent}
        </div>
    </div>
    )
}

--- C:\Users\Rosja Dostoyevsjky\Documents\Visual Studio Code\to_do\src\app\note_container\task_check_box\task_check_box.tsx ---
export const TaskCheckBox = () => {
    return (
        <div className="checkbox-wrapper-60">
  <input type="checkbox" className="check" id="check1-60"/>
  <label htmlFor="check1-60" className="label">
    <svg viewBox="0 0 65 65" height="30" width="30">
      <rect x="7" y="7" width="50" height="50" stroke="black" fill="none" />
      <g transform="translate(-23,-967.36216)" id="layer1-60">
        <path id="path4146" d="m 55,978 c -73,19 46,71 15,2 C 60,959 13,966 30,1007 c 12,30 61,13 46,-23" fill="none" stroke="black" strokeWidth="3" className="path1" />
      </g>
    </svg>
    <span className={"inline-flex"}>Checkbox</span>
  </label>
  <p className={"note-content"}>Just some note text</p>
</div>
    )
}
